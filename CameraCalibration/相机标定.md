# OpenCV相机标定函数

## cv2.findChessboardCorners()

`cv2.findChessboardCorners()`函数是OpenCV中用于检测棋盘格角点的函数。它主要用于相机标定，因为在标定过程中通常会使用棋盘格作为标定板。该函数的作用是在输入图像中检测棋盘格角点的位置。

### 函数语法：

```python
ret, corners = cv2.findChessboardCorners(image, patternSize, corners=None, flags=None)
```

### 参数说明：

- `image`：输入图像，通常是灰度图像。

- `patternSize`：棋盘格的尺寸，以`(rows, cols)`形式指定，其中`rows`表示棋盘格的行数，`cols`表示棋盘格的列数。

- `corners`：可选参数，用于存储检测到的棋盘格角点的数组。

- `flags`：可选参数，用于指定检测棋盘格角点的标志。

### 返回值说明：

- `ret`：返回一个布尔值，指示是否成功检测到棋盘格角点。

- `corners`：返回一个包含检测到的棋盘格角点坐标的数组。如果函数成功检测到了角点，则`corners`中将包含所有角点的坐标。



## cv2.cameraCalibration()

`cv2.calibrateCamera()`函数用于相机标定，其主要目的是确定相机的内部参数矩阵（Camera Matrix）和畸变系数（Distortion Coefficients），这两者可以用来对图像进行校正。

### 函数语法：

```python
ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(object_points, image_points, image_size, camera_matrix=None, dist_coeff=None, flags=None, criteria=None)
```

### 参数说明：

- `object_points`：包含标定板上角点的世界坐标的列表。每个元素都是一个numpy数组，包含标定板上的三维点的坐标。数组的大小应该和`image_points`中对应的图像角点一致。

- `image_points`：包含图像上检测到的角点的像素坐标的列表。每个元素都是一个numpy数组，包含标定板上的二维点的像素坐标。数组的大小应该和`object_points`中对应的世界坐标一致。

- `image_size`：图像的大小，以`(width, height)`形式给出。

- `camera_matrix`：相机的内部参数矩阵。如果提供了初始值，则使用提供的值，否则函数将计算它。

- `dist_coeff`：相机的畸变系数。如果提供了初始值，则使用提供的值，否则函数将计算它。

- `flags`：标定选项。通常情况下，可以使用默认值`None`。

- `criteria`：用于指定标定算法的终止准则。

### 返回值说明：

- `ret`：标定的平均重投影误差。这个值越小越好。
- `mtx`：相机的内部参数矩阵。
- `dist`：相机的畸变系数。
- `rvecs`：每个图像的旋转向量。
- `tvecs`：每个图像的平移向量。

### 返回值shape

`cv2.calibrateCamera()` 函数返回的值的形状如下：

- `ret`：标定的平均重投影误差，是一个标量。
- `mtx`：相机的内部参数矩阵，是一个形状为 `(3, 3)` 的矩阵。
- `dist`：相机的畸变系数，通常是一个形状为 `(5,)` 的一维数组（对于 `distCoeffs`）。
- `rvecs`：每个图像的旋转向量，是一个形状为 `(N, 3)` 的二维数组，其中 `N` 是图像数量。
- `tvecs`：每个图像的平移向量，是一个形状为 `(N, 3)` 的二维数组，其中 `N` 是图像数量。

具体而言：

- `ret` 是一个标量，即一个单一的数值，表示标定的平均重投影误差。
- `mtx` 是一个形状为 `(3, 3)` 的矩阵，表示相机的内部参数。
- `dist` 是一个形状为 `(5,)` 的一维数组，其中包含了相机的畸变系数。
- `rvecs` 是一个形状为 `(N, 3)` 的二维数组，其中 `N` 是图像数量，每行包含了一个图像的旋转向量。
- `tvecs` 是一个形状为 `(N, 3)` 的二维数组，其中 `N` 是图像数量，每行包含了一个图像的平移向量。

这些返回值提供了相机标定过程中得到的重要参数信息，可以用来进行图像校正、三维重建等后续处理。

### criteria参数定义

在 `cv2.calibrateCamera()` 函数中，`criteria` 参数用于指定标定算法的终止准则。通常情况下，我们可以将其设置为一个 `cv2.TermCriteria` 对象，用于控制标定算法的迭代停止条件。`cv2.TermCriteria` 对象可以通过设置最大迭代次数、最大角点移动距离或者迭代的精度等来指定终止准则。

一般来说，可以使用以下方式指定 `criteria` 参数：

```python
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, max_iter, epsilon)
```

其中：

- `cv2.TERM_CRITERIA_EPS` 表示通过精度来终止迭代的条件。
- `cv2.TERM_CRITERIA_MAX_ITER` 表示通过最大迭代次数来终止迭代的条件。
- `max_iter` 是最大迭代次数。
- `epsilon` 是迭代的精度阈值。

通常情况下，我们会同时设置这两个条件，比如指定最大迭代次数为 30，迭代的精度阈值为 0.001：

```python
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
```

这样设置 `criteria` 参数可以确保标定算法在达到最大迭代次数或者达到指定的精度阈值时停止迭代，从而提高标定的稳定性和精度。

在实际应用中，`criteria` 参数的设置可能会根据具体情况进行调整，比如根据图像数据的质量和标定的精度要求来确定最大迭代次数和精度阈值。

## cv2.cornerSubPix()

这段代码使用了 OpenCV 中的 `cv2.cornerSubPix()` 函数来在图像中寻找亚像素级别的角点，并将找到的亚像素角点作为新的图像坐标。接下来，我会逐行解释这段代码：

```python
corners2 = cv2.cornerSubPix(gray, corners, (5, 5), (-1, -1), criteria)
```

- `gray`：灰度图像，即标定板图像的灰度版本。
- `corners`：原始检测到的角点的像素坐标，通常使用 `cv2.findChessboardCorners()` 函数检测得到。
- `(5, 5)`：角点搜索窗口的大小，以像素为单位。这个窗口用于在原始角点周围搜索更准确的亚像素级别的角点。
- `(-1, -1)`：角点搜索的停止条件。这里设置为 `-1, -1` 表示使用默认的停止条件，通常是迭代次数或者角点移动的阈值。
- `criteria`：用于定义角点搜索的终止条件的标准。这个参数通常是一个 `cv2.TermCriteria` 对象，用于控制搜索算法的停止条件，比如最大迭代次数或者最大角点移动距离。

`cv2.cornerSubPix()` 函数的作用是在原始角点的基础上进行亚像素级别的精确化，它会在原始角点周围的一个小窗口内搜索更精确的角点位置。这样做的目的是提高角点坐标的准确性，从而提高相机标定的精度。

接着，代码检查是否成功找到了亚像素级别的角点：

```python
if [corners2]:
    img_points.append(corners2)
else:
    img_points.append(corners)
```

如果成功找到了亚像素级别的角点，那么将这些角点加入到 `img_points` 列表中；否则，将使用原始角点。这个列表通常用于存储每个图像中检测到的角点的像素坐标，以便后续的相机标定过程中使用。

总之，这段代码通过 `cv2.cornerSubPix()` 函数对原始角点进行亚像素级别的精确化，从而提高了角点坐标的准确性，为相机标定提供了更精确的图像坐标。

### cv2.undistort()

`cv2.undistort()` 函数用于校正图像中的畸变，其基本语法如下：

```python
undistorted_img = cv2.undistort(src, cameraMatrix, distCoeffs, newCameraMatrix=None, dst=None)
```

参数说明：
- `src`: 输入图像，即需要进行畸变校正的图像，通常是一个 OpenCV 图像对象（如通过 `cv2.imread()` 读取的图像）。
- `cameraMatrix`: 相机内部参数矩阵，即相机的内参矩阵。它是一个 3x3 的矩阵，包含了相机的焦距、主点位置等信息。
- `distCoeffs`: 畸变系数，通常是一个包含畸变系数的数组或矩阵。畸变系数包括径向畸变和切向畸变等信息。
- `newCameraMatrix` (可选): 可选的新相机内部参数矩阵。如果指定了新的相机内参矩阵，函数将根据新的内参矩阵重新映射图像，并返回映射后的图像。
- `dst` (可选): 可选的输出图像，即校正后的图像。如果未指定，函数会自动创建一个与输入图像大小相同的输出图像。

返回值：
- `undistorted_img`: 校正后的图像，即去除了畸变效果的图像。

在使用 `cv2.undistort()` 函数时，需要提供相机的内参矩阵和畸变系数。函数会根据这些参数对输入图像进行畸变校正，返回校正后的图像。如果指定了新的相机内部参数矩阵，则根据新的内参矩阵重新映射图像，并返回映射后的图像。

# 相机标定需求

需求：

1. 假如五个相机组成的相机阵列要拍摄一个场景，这个场景由九帧图像组成（这个相机阵列共拍摄9次，每帧包含五个相机拍的五张图），那么需要对每帧对应的这5张照片 按照相机摆放的样子进行**`行对准`**和**`列对准`**，

2. 对于每帧的这五张图片，需要保证他们之间两两之间的baseline相等

问题：

- 有个问题：进行**`行对准`**和**`列对准`**的对象是**不同相机拍的同一视角照片，那对于同一相机拍摄的不同视角照片是不是也需要对准？**因为我们用相机阵列拍摄完一帧照片需要再移动相机阵列的视角进行拍摄，那这个移动的过程如果是平移的话，按理说也应该保证平移过程的行对准。
- 还有个点是，我们拍摄的数据集对于行列对准要求比较严格，那么在标定的时候尽量让标定板占据图像的大部分，这样标准的准确度会高点。所以要买的标定板是不是需要稍微大点，不然标定板占据图像范围太小的话没法保证对准的准确性。想问下常老师是不是这样



- 有了这些照片，我们在做实验的时候是怎么用这些照片的，了解大致的处理流程也方便我在标定的时候尽量满足需求

常老师，我总结了一下我们刚才聊得内容，想和常老师确认一下，然后又想到两个问题麻烦常老师看下

# 资料参考

## 如何利用单应性进行图像对齐

在利用相机拍摄标定网格后，如果需要将相机拍摄的图像对齐到指定的参考平面，可以通过以下步骤进行单应性矫正：

1. **相机标定（Camera Calibration）**：
   在标定之前，需要使用一系列已知的三维点（例如标定板上的棋盘格点）和它们在相机坐标系下的对应二维点来标定相机。这个过程会得到相机的内部参数（如焦距、畸变系数等）和外部参数（相机的位置和朝向）。OpenCV等库提供了用于相机标定的工具。

2. **单应性矫正（Homography Estimation）**：
   使用标定好的相机参数，可以计算图像与参考平面之间的单应性矩阵（homography matrix）。这个矩阵描述了图像中的点与参考平面之间的投影关系。在OpenCV中，可以使用`cv2.findHomography()`函数来估计单应性矩阵。

3. **图像矫正（Image Rectification）**：
   将单应性矩阵应用于原始图像，可以将图像中的点映射到参考平面上，实现对图像的矫正。在OpenCV中，可以使用`cv2.warpPerspective()`函数来应用单应性矩阵并实现图像的矫正。

4. **后续处理**：
   在图像矫正之后，可能需要进行一些后续处理，比如裁剪图像以去除矫正后图像边缘上的空白部分，或者进一步处理矫正后的图像以满足特定需求。

总的来说，通过相机标定和单应性矫正，可以将相机拍摄的图像对齐到指定的参考平面上，从而方便后续的分析和处理。

​	